module Data.Group.Free (FreeGroup(..), free, Signed(..), foldFree) where

import Prelude

import Data.Foldable (foldr)
import Data.Group (class Group, ginverse)
import Data.List (List(..), reverse, (:))

-- | A data type indicating the sign of one of the generators of the free group.
data Signed a = Positive a | Negative a

derive instance eqSigned :: Eq a => Eq (Signed a)

instance showSigned :: Show a => Show (Signed a) where
  show (Positive x) = "+" <> show x
  show (Negative x) = "-" <> show x

-- Reduce a term of a free group to canonical form.
canonical :: forall a. Eq a => List (Signed a) -> List (Signed a)
canonical = foldr cancelOrPush Nil where
  cancelOrPush x@(Positive x1) y@(Negative y1 : tl) = if x1 == y1 then tl else x : y
  cancelOrPush x@(Negative x1) y@(Positive y1 : tl) = if x1 == y1 then tl else x : y
  cancelOrPush x y = x : y

-- | The free group generated by elements of `a`, up to equality.
-- | Note that the `Eq` and `Monoid` instances differ from the standard such instances for `List (Signed a)`; two elements of the free group are equal iff they are equal after being reduced to "canonical form", i.e., cancelling adjacent inverses.
newtype FreeGroup a = FreeGrp (List (Signed a))

-- | Lift a value of type `a` to a value of type `FreeGroup a`
free :: forall a. a -> FreeGroup a
free x = FreeGrp $ Positive x : Nil

-- | Lift a function from `a` to some group `b` into the unique induced homomorphism from `FreeGroup a` to `b`.
foldFree :: forall a b. Group b => (a -> b) -> FreeGroup a -> b
foldFree f (FreeGrp xs) = foldr (\a b -> f' a <> b) mempty xs
  where
  f' (Positive x) = f x
  f' (Negative x) = ginverse (f x)

instance eqFreeGrp :: Eq a => Eq (FreeGroup a) where
  eq (FreeGrp x) (FreeGrp y) = canonical x == canonical y

instance showFreeGrp :: Show a => Show (FreeGroup a) where
  show (FreeGrp x) = show x

instance semigrpFreeGrp :: Eq a => Semigroup (FreeGroup a) where 
  append (FreeGrp x) (FreeGrp y) = FreeGrp $ canonical $ x <> y

instance monoidFreeGrp :: Eq a => Monoid (FreeGroup a) where
  mempty = FreeGrp Nil

instance groupFreeGrp :: Eq a => Group (FreeGroup a) where
  ginverse (FreeGrp fg) = FreeGrp $ reverse $ map flipSign fg where
    flipSign (Positive x) = Negative x
    flipSign (Negative x) = Positive x
